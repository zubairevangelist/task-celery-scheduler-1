from contextlib import asynccontextmanager
import datetime
import os
from typing import Optional
from fastapi import Depends, FastAPI
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
import time

from pydantic import EmailStr
from sqlmodel import Field, SQLModel, Session, create_engine, select
import uvicorn



from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

POSTGRES_USER = os.getenv("POSTGRES_USER", "myuser")
POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "mypassword")
POSTGRES_DB = os.getenv("POSTGRES_DB", "mydatabase")
POSTGRES_HOST = os.getenv("POSTGRES_HOST", "localhost")
POSTGRES_PORT = os.getenv("POSTGRES_PORT", 5432)



REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = os.getenv("REDIS_PORT", 6379)


# Create Database Tables on Startup
@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Creating database tables...")
    
    print("Database tables are ready.")
    yield  # Continue running the app
    print("Shutting down...")

# FastAPI App with Lifespan
app = FastAPI(lifespan=lifespan)


# Create a scheduler
scheduler = BackgroundScheduler()

# Example task
def scheduled_task():
    print(f"Task executed at {time.strftime('%Y-%m-%d %H:%M:%S')}")

# Add a job that runs every minute
scheduler.add_job(scheduled_task, CronTrigger(minute="*"))

# Start the scheduler
scheduler.start()

@app.get("/")
def read_root():
    return {"message": "APScheduler running with FastAPI"}

from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

# Database Connection
# DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}"
# DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}"
DATABASE_URL = "postgresql://myuser:mypassword@localhost:5432/mydatabase"
print(DATABASE_URL)

engine = create_engine(DATABASE_URL, echo=True)

def get_session():
    with Session(engine) as session:
        yield session

#  Define the SQLModel
class ScheduleTasks(SQLModel, table=True):
    __tablename__ = "schedule_tasks"
    id: Optional[int] = Field(default=None, primary_key=True)
    task_ip: str = Field(nullable=True)
    # task_api: str = Field(nullable=True)
    task_domain: str = EmailStr
    task_frequency: str = Field(..., regex="^(daily|weekly|monthly|yearly)$", nullable=True)
    task_title: str = Field(nullable=True)
    task_priority: Optional[str] = Field(default=None, regex="^(low|medium|high)$")
    task_date: datetime.date = Field(nullable=True)
    task_time: datetime.time = Field(nullable=True)
    user_id: str = Field(nullable=True)

    
@app.get("/tasks/", response_model=list[ScheduleTasks])
def get_tasks(session: Session = Depends(get_session)):
    tasks = session.exec(select(ScheduleTasks)).all()
    return tasks


if __name__ == '__main__':
    uvicorn.run(app, host='0.0.0.0', port=8000)